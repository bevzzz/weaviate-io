---
title: Manage resource costs
sidebar_position: 20
image: og/wcs/user_guides.jpg
---

Weaviate Cloud provides flexible resource management features that let you balance system performance and system resource costs.

Indexes and compression are powerful tools. This page discusses configuration strategies to help you configure indexes and compression to get the most value from Weaviate Cloud.

## Compression

import VectorsBig from '/_includes/starter-guides/vectors-are-big.mdx';

<VectorsBig/>

Careful choice of indexes and compression can significantly reduce the hosting requirements for your collection. Lower hosting requirements translate directly to cost savings.

### Compression algorithms

These compression algorithms are available in Weaviate Cloud:

import CompressionAlgorithms from '/_includes/starter-guides/compression-types.mdx';

<CompressionAlgorithms />

import CostSavings from '/_includes/starter-guides/cost-savings.mdx';

<CostSavings/>

### Price calculator

The Cloud [pricing calculator](https://weaviate.io/pricing) demonstrates the savings with compressed indexes.

To use the calculator, enter the number of objects in your collection and the dimensionality of each object. Under `Storage Type`, select "Compression". Compare the costs for "Performance" and for "Compression."

Compressed storage is significantly cheaper.

## Compression availability

This table shows the compression algorithms that are available for each index type.

| Compression type | HNSW index | Flat index | Dynamic index |
| :- | :- | :- | :- |
| PQ | Yes | No | Yes |
| SQ | Yes | No | Yes |
| BQ | Yes | Yes | Yes |

## Activate compression

You should define a compression algorithm when you define your collection.

import ActivateComp from '/_includes/starter-guides/activate-compression.mdx';

<ActivateComp/>

## Performance

Performance has multiple components. Recall and response latency are important considerations at query time. Indexing speed is important for data imports and updates. Compression and index choice both affect performance.

### Recall

import RecallDetails from '/_includes/starter-guides/recall-details.mdx';

<RecallDetails/>

### Query speed

import QuerySpeed from '/_includes/starter-guides/query-speed.mdx';

<QuerySpeed/>

### Import speed

Importing and compressing vectors takes slightly longer than importing uncompressed vectors, but this is a one time cost. In contrast, loading a compressed index into memory is faster since there is less data to load. This means restarts are faster.

## Asynchronous indexing

[Asynchronous indexing](/developers/weaviate/config-refs/schema/vector-index#asynchronous-indexing) changes the import process. In many cases, you can work with newly imported data sooner if asynchronous indexing is enabled. Asynchronous indexing is also a prerequisite for dynamic indexes.

### Enable async indexing

Enable asynchronous indexing to improve imports and to allow dynamic indexes.

import EnableAsync from '/developers/wcs/img/wcd-enable-async.jpg';

<img src={EnableAsync} width="100%" alt="Enable asynchronous indexing"/>

#### New clusters

1. Go to the cluster creation page.
1. Under `Advanced Configuration`, select `Enable async indexing`.

#### Existing clusters

1. Go to the cluster details page.
1. Under `Advanced Configuration`, select `Enable async indexing`.
1. Select save to restart the cluster.

:::warning Possible downtime
If you have a stand-alone cluster, the update requires system downtime. Consider your business needs, and update your cluster when you have a suitable maintenance window.<br/><br/>

There is no downtime if you have a high availability (HA) cluster.
:::

## Indexing

Vector indexes are a central feature of the Weaviate database. These indexes enable efficient search of large vector spaces. Weaviate also uses inverted indexes. Inverted indexes are used for filtering and keyword searches.

### Vector indexes

import IndexesIntro from '/_includes/starter-guides/indexes-intro.mdx';

<IndexesIntro/>

### HNSW indexes

[HNSW indexes](/developers/weaviate/concepts/vector-index#hierarchical-navigable-small-world-hnsw-index) are high-performance, in-memory indexes. HNSW indexes scale well. Vector searches are fast, even for very large data sets.

HNSW indexes enable fast searches, but they also require a lot of RAM memory to load the index and the underlying vector embeddings. RAM is an expensive resource. To see how compression can lower costs in Weaviate Cloud, use the [price calculator](#price-calculator) to estimate your savings compared to uncompressed indexes.

Quantization is an effective way to compress the vector embeddings. Weaviate provides these quantization algorithms that compress HNSW indexes:

- [Product quantization (PQ)](/developers/weaviate/configuration/compression/pq-compression)
- [Scalar quantization (SQ)](/developers/weaviate/configuration/compression/sq-compression)
- [Binary quantization (BQ)](/developers/weaviate/configuration/compression/bq-compression)

### Flat indexes

import IndexesFlatAbout from '/_includes/starter-guides/indexes-flat-about.mdx';

<IndexesFlatAbout/>

Flat indexes are usually smaller than HNSW indexes since they index fewer vectors. However, flat indexes can also benefit from compression.

[Binary quantization (BQ)](/developers/weaviate/configuration/compression/bq-compression) improves search time by reducing the amount of data to read, and by shortening the time needed to calculate distances between vectors. If you have a lot of tenants, BQ also saves significant space on disk. Each compressed index is roughly 1/32 the size of an uncompressed index.

### Dynamic indexes

:::info Added in `v1.25`
:::

import DynamicAbout from '/_includes/starter-guides/indexes-dynamic-about.mdx';

<DynamicAbout/>

:::info Configure the flat index and the HNSW index
Configure the flat index and the HNSW index when you define the dynamic index. The dynamic index uses the flat index initially, then switches to the HNSW index. Both indexes should be configured before they are used.
:::

## Inverted indexes

Inverted indexes don't use resources the same way as vector indexes, however you can still configure inverted indexes to make better use of the resources they do use.

The `invertedFilterable` and `invertedSearchable` indexes are enabled by default on collection properties.

- If you never search or filter on a property, turn off `invertedFilterable` and `invertedSearchable` indexing.
- If you only filter on a property occasionally, turn off `invertedFilterable` indexing. The property is still filterable, just less efficiently.

[Turn off](/developers/weaviate/manage-data/collections#property-level-settings) these indexes to save disk space. Turning them off also improves import times since Weaviate has to do less work for each object that it imports.

## Recommendations

Most applications benefit from compression.

- If you have a small collection that uses a flat index, consider a BQ index. The BQ index is 32 times smaller and much faster than the uncompressed equivalent.
- For collections that are small, but that are expected to grow, consider a dynamic index. In addition to setting the dynamic index type, configure the collection to use BQ compression while the index is flat and SQ compression when the collection grows large enough to move from a flat index to an HNSW index.
- Most users with medium to large data sets should consider SQ compression. SQ compressed vectors are one quarter the size of uncompressed vectors. Searches with SQ are faster than searches with uncompressed vectors. Recall is similar to uncompressed vectors.
- If you have a very large data set or specialized search needs, consider PQ compression. PQ compression is very configurable, but it requires more expertise to tune well than SQ or BQ.
- For multi-tenant collections, consider the sizes of the tenants. The index and compression recommendations are the same for individual tenants as for single collections.

## Support

import SupportAndTrouble from '/_includes/wcs/support-and-troubleshoot.mdx';

<SupportAndTrouble />